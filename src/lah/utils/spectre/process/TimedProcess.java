package lah.utils.spectre.process;

import java.io.File;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;

import lah.utils.spectre.BuildConfig;
import lah.utils.spectre.CollectionPrinter;
import lah.utils.spectre.interfaces.ExceptionHandler;
import lah.utils.spectre.interfaces.ResultListener;
import lah.utils.spectre.stream.InputBufferProcessor;
import lah.utils.spectre.stream.InputStreamProcessingThread;

/**
 * This class is an extension of the standard {@link Process} with the extra
 * capability of being timed out. It also provides convenient ways to handle
 * generated standard output.
 * 
 * @author L.A.H.
 * 
 */
public class TimedProcess {

	/**
	 * The command to execute
	 */
	protected String[] command;

	/**
	 * Background thread to process standard output generated by the process
	 */
	protected Thread stdout_processing_thread;

	/**
	 * The external process forked for execution
	 */
	protected Process process;

	/**
	 * An executing task that will kill the process when time out is reached
	 */
	protected TimerTask process_killer;

	public TimedProcess(String[] command, File working_directory,
			boolean redirect_stderr) throws IOException {
		this.command = command;
		process = new ProcessBuilder(command).directory(working_directory)
				.redirectErrorStream(redirect_stderr).start();
	}

	public TimedProcess(String[] command, File working_directory,
			boolean redirect_stderr, InputBufferProcessor processor,
			ExceptionHandler stdout_processing_exception_handler, long timeout)
			throws IOException {
		this(command, working_directory, redirect_stderr);
		setStdOutHandler(processor, stdout_processing_exception_handler, null);
		setAndStartTimeOut(timeout);
	}

	public TimedProcess(String[] command, File directory,
			boolean redirectError, InputBufferProcessor processor, long timeout)
			throws IOException {
		this(command, directory, redirectError);
		setStdOutHandler(processor);
		setAndStartTimeOut(timeout);
	}

	TimedProcess() {
	}

	/**
	 * Kill the process and wait for the standard output processing thread to
	 * finish with the remaining output
	 */
	public void destroy() {
		if (BuildConfig.DEBUG)
			System.out.println("Destroy timed process " + this + " running "
					+ CollectionPrinter.stringOfArray(command, " ", "[", "]"));
		// Kill the process and close resources
		kill();
		// Wait for the output processing thread to finish
		try {
			if (stdout_processing_thread == null)
				return;
			stdout_processing_thread.join();
		} catch (Exception e) {
		}
	}

	/**
	 * Destroy the running process and close all associated resources
	 * (input/output streams)
	 */
	public void kill() {
		try {
			if (process == null)
				return;

			// Kill and wait for the process to be really killed
			process.destroy();
			process.waitFor();

			// Close the associated streams
			if (process.getInputStream() != null)
				process.getInputStream().close();
			if (process.getOutputStream() != null)
				process.getOutputStream().close();
			if (process.getErrorStream() != null)
				process.getErrorStream().close();

			// Cancel the scheduled killing
			if (process_killer != null)
				process_killer.cancel();
		} catch (Exception e) {
			// Ignore any exception
		}
	}

	public Process getProcess() {
		return process;
	}

	public TimerTask getProcessKillingTask() {
		return process_killer;
	}

	public void setAndStartTimeOut(long timeout) {
		if (timeout > 0) {
			process_killer = new TimerTask() {

				@Override
				public void run() {
					destroy();
				}
			};
			new Timer().schedule(process_killer, timeout);
		}
	}

	public void setStdOutHandler(InputBufferProcessor processor) {
		setStdOutHandler(processor, null, null);
	}

	public void setStdOutHandler(InputBufferProcessor processor,
			ExceptionHandler exception_handler,
			ResultListener<Void> result_listener) {
		if (process != null) {
			stdout_processing_thread = new InputStreamProcessingThread(
					process.getInputStream(), processor, exception_handler,
					result_listener);
			stdout_processing_thread.start();
		}
	}

	public int waitFor() throws InterruptedException {
		return process.waitFor();
	}

	public int waitForAndDestroy() throws InterruptedException {
		int result = process.waitFor();
		destroy();
		return result;
	}

}